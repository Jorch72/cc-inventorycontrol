os.loadAPI("ocs/apis/sensor")

local invSensor = nil
local tankSensor = nil
local euSensor = nil
local outputTable = {}

for _, side in pairs(rs.getSides()) do
	outputTable[side] = {redstone = 0}
	for k, v in pairs(colors) do
		if type(k) == "string" and type (v) == "number" then
			--catch all the color aliases and create entries for them
			outputTable[side][k] = 0
		end
	end
end

for _, side in pairs(rs.getSides()) do
	if peripheral.getType(side) == "sensor" then
		if sensor.call(side, "getSensorName") == "openccsensors.item.inventorysensor" then
			invSensor = side
		elseif sensor.call(side, "getSensorName") == "openccsensors.item.tanksensor" then
			tankSensor = side
		elseif sensor.call(side, "getSensorName") == "openccsensors.item.industrialcraftsensor" then
			euSensor = side
		end
	end
	if invSensor and tankSensor then break end
end

local testConditions = {
	tank = {
		full = function(coord)
			local tankData = sensor.call(tankSensor, "getTargetDetails", coord)
			if tankData.Amount >= tankData.Capacity then
				return true
			else
				return false
			end
		end,
		partial = function(coord)
			local tankData = sensor.call(tankSensor, "getTargetDetails", coord)
			if tankData.Amount < tankData.Capacity and tankData.Amount > 0 then
				return true
			else
				return false
			end
		end,
		empty = function(coord)
			local tankData = sensor.call(tankSensor, "getTargetDetails", coord)
			if tankData.Amount <= 0 then
				return true
			else
				return false
			end
		end,
	},
	inventory = {
		full = function(coord)
			local inventoryData = sensor.call(invSensor, "getTargetDetails", coord)
			for _, slot in pairs(inventoryData) do
				if slot.Size < slot.MaxStack then
					return false
				end
			end
			return true
		end,
		partial = function(coord)
			local inventoryData = sensor.call(invSensor, "getTargetDetails", coord)
			local totalSize = 0
			local totalMax = 0
			for _, slot in pairs(inventoryData) do
				if slot.Size < slot.MaxStack and slot.Size > 0 then
					return true
				end
				totalSize = totalSize + slot.Size
				totalMax = totalMax + slot.MaxStack
			end
			--catch the all slot are empty or full, but not all empty or all full case.
			if totalSize < totalMax and totalSize > 0 then
				return true
			else
				return false
			end
		end,
		empty = function(coord)
			local inventoryData = sensor.call(invSensor, "getTargetDetails", coord)
			for _, slot in pairs(inventoryData) do
				if slot.Size > 0 then
					return false
				end
			end
			return true
		end,
	},
	euStorage = {
		full = function(coord)
			local euStorageData = sensor.call(euSensor, "getTargetDetails", coord)
			if euStorageData.Stored >= euStorageData.Capacity then
				return true
			else
				return false
			end
		end,
		partial = function(coord)
			local euStorageData = sensor.call(euSensor, "getTargetDetails", coord)
			if euStorageData.Stored < euStorageData.Capacity and euStorageData.Stored > euStorageData.Output then
				return true
			else
				return false
			end
		end,
		empty = function(coord)
			local euStorageData = sensor.call(euSensor, "getTargetDetails", coord)
			if euStorageData.Stored < euStorageData.Output then
				return true
			else
				return false
			end
		end,
	},
}

local function setOutput(side, color, state)
	if state then
		outputTable[side][color] = outputTable[side][color] + 1
		if color == "redstone" then
			if not rs.getOutput(side) then
				rs.setOutput(side, true)
			end
		else
			if not colors.test(rs.getBundledOutput(side), colors[color]) then
				rs.setBundledOutput(side, colors.combine(rs.getBundledOutput(side), colors[color]))
			end
		end
	else
		outputTable[side][color] = outputTable[side][color] - 1
		if outputTable[side][color] == 0 then
			if color == "redstone" then
				rs.setOutput(side, false)
			else
				if colors.test(rs.getBundledOutput(side), colors[color]) then
					rs.setBundledOutput(side, colors.subtract(rs.getBundledOutput(side), colors[color]))
				end
			end
		end
	end
end

local configurationTable = {}

local pulseTable = {}

local function setPulsing(info, state)
	if state then
		--add the entry to the pulse table
		pulseEntry = {
			side = info.side
			color = info.color
			duration = info.duration
			count = info.count
			delay = info.delay
			timer = os.startTimer(0)
			pulseState = false
			handle = info
		}
		table.insert(pulseTable, pulseEntry)
	else
		for i = 1, #pulseTable do
			if pulseTable[i].handle == info then
				if pulseState then
					setOutput(info.side, info.color, false)
				end
				table.remove(pulseTable, i)
				break
			end
		end
	end
end

local updateTime, updateTimer = 5, os.startTimer(0)

while true do
	event = {os.pullEvent()}
	if event[1] == "timer" and event[2] == updateTimer then
		for eNum, eInfo in pairs(configurationTable) do
			--iterate the entry's conditions
			local condTrueCount, condFalseCount = 0, 0
			for cNum, cInfo in pairs(eInfo.conditions) do
				if testConditions[cInfo.type][cInfo.state](cInfo.location) then
					condTrueCount = condTrueCount + 1
				else
					condFalseCount = condFalseCount + 1
				end
			end
			local setState = nil
			if ((eInfo.conditionType == "or" and condTrueCount > 0) or (eInfo.conditionType == "and" and condFalseCount == 0) and eInfo.lastState == false then
				--condition is true and needs to be set.
				setState = true
			elseif ((eInfo.conditionType == "or" and condTrueCount == 0) or (eInfo.conditionType == "and" and condFalseCount > 0) and eInfo.lastState == true then
				--condition is false and needs to be set.
				setState = false
			end
			if setState ~= nil then
				for oNum, oInfo in pairs(eInfo.outputs) do
					if oInfo.state ~= "pulse" then
						setOutput(oInfo.side, oInfo.color, ((oInfo.state == "high") == setState))
					else
						setPulsing(oInfo, setState))
					end
				end
				setState = nil
			end
		end
		updateTimer = os.startTimer(updateTime)
	elseif event[1] == "timer" then
		for pNum, pInfo in pairs(pulseTable) do
			if event[2] == pInfo.timer then
				if pInfo.pulseState then
					pInfo.count = pInfo.count - 1
					setOutput(pInfo.side, pInfo.color, false)
					if pInfo.count > 0 then
						pInfo.timer = os.startTimer(pInfo.delay)
					else
						table.remove(pulseTable, pNum)
					end
				else
					setOutput(pInfo.side, pInfo.color, true)
					pInfo.timer = os.startTimer(pInfo.duration)
				end
				break
			end
		end
	end
end
