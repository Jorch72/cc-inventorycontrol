os.loadAPI("ocs/apis/sensor")

local invSensor = nil
local tankSensor = nil
local outputTable = {}

for _, side in pairs(rs.getSides()) do
	outputTable[side] = {raw = 0}
	for k, v in pairs(colors) do
		if type(k) == "string" and type (v) == "number" then
			--catch all the color aliases and create entries for them
			outputTable[side][k] = 0
		end
	end
end

for _, side in pairs(rs.getSides()) do
	if peripheral.getType(side) == "sensor" then
		if sensor.call(side, "getSensorName") == "openccsensors.item.inventorysensor" then
			invSensor = side
		elseif sensor.call(side, "getSensorName") == "openccsensors.item.tanksensor" then
			tankSensor = side
		end
	end
	if invSensor and tankSensor then break end
end

local tankTest = {
	full = function(coord)
		local tankData = sensor.call(tankSensor, "getTargetDetails", coord)
		if tankData.Amount >= tankData.Capacity then
			return true
		else
			return false
		end
	end,
	partial = function(coord)
		local tankData = sensor.call(tankSensor, "getTargetDetails", coord)
		if tankData.Amount < tankData.Capacity and tankData.Amount > 0 then
			return true
		else
			return false
		end
	end,
	empty = function(coord)
		local tankData = sensor.call(tankSensor, "getTargetDetails", coord)
		if tankData.Amount <= 0 then
			return true
		else
			return false
		end
	end,
}

local inventoryTest = {
	full = function(coord)
		local inventoryData = sensor.call(invSensor, "getTargetDetails", coord)
		for _, slot in pairs(inventoryData) do
			if slot.Size < slot.MaxStack then
				return false
			end
		end
		return true
	end,
	partial = function(coord)
		local inventoryData = sensor.call(invSensor, "getTargetDetails", coord)
		local totalSize = 0
		local totalMax = 0
		for _, slot in pairs(inventoryData) do
			if slot.Size < slot.MaxStack and slot.Size > 0 then
				return true
			end
			totalSize = totalSize + slot.Size
			totalMax = totalMax + slot.MaxStack
		end
		--catch the all slot are empty or full, but not all empty or all full case.
		if totalSize < totalMax and totalSize > 0 then
			return true
		else
			return false
		end
	end,
	empty = function(coord)
		local inventoryData = sensor.call(invSensor, "getTargetDetails", coord)
		for _, slot in pairs(inventoryData) do
			if slot.Size > 0 then
				return false
			end
		end
		return true
	end,
}

local euPowerTest = {
	full = function(coord)
		local euStorageData = sensor.call(euSensor, "getTargetDetails", coord)
		if euStorageData.Stored >= euStorageData.Capacity then
			return true
		else
			return false
		end
	end,
	partial = function(coord)
		local euStorageData = sensor.call(euSensor, "getTargetDetails", coord)
		if euStorageData.Stored < euStorageData.Capacity and euStorageData.Stored > euStorageData.Output then
			return true
		else
			return false
		end
	end,
	empty = function(coord)
		local euStorageData = sensor.call(euSensor, "getTargetDetails", coord)
		if euStorageData.Stored < euStorageData.Output then
			return true
		else
			return false
		end
	end,
}

local function setBundledOutput(side, color, state)
	if state then
		outputTable[side][color] = outputTable[side][color] + 1
		if not colors.test(rs.getBundledOutput(side), colors[color]) then
			rs.setBundledOutput(side, colors.combine(rs.getBundledOutput(side), colors[color]))
		end
	else
		outputTable[side][color] = outputTable[side][color] - 1
		if outputTable[side][color] == 0 then
			if colors.test(rs.getBundledOutput(side), colors[color]) then
				rs.setBundledOutput(side, colors.subtract(rs.getBundledOutput(side), colors[color]))
			end
		end
	end
end

local function setRedstoneOutput(side, state)
	if state then
		outputTable[side].raw = outputTable[side].raw + 1
		if not rs.getOutput(side) then
			rs.setOutput(side, true)
		end
	else
		outputTable[side].raw = outputTable[side].raw - 1
		if outputTable[side].raw == 0 then
			rs.setOutput(side, false)
		end
	end
end
